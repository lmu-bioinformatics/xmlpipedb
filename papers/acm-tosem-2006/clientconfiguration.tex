\subsubsection{Client Configuration}

\paragraph{Reason for Component}
In order to make the tools as easy to use as possible the issue of Hibernate properties configuration had to be addressed. Hibernate supports a wide variety of databases and data access methods. While advantageous for technical people, this can make configuration a daunting task for others. We chose an approach that would be modular, allowing the configuration component to be plugged into any application seamlessly.  


\paragraph{Design}
There were several challenges in the design of this component. First was to determine how to break down the myriad of supported database connection types and sundry other properties in a logical, straight forward and convenient way. Next was the issue of flexibility. We wanted a design that would adapt to changes in the hibernate properties structure. This is particularly important in this type of project, since Hibernate is not under our control and therefore could change how they are doing things at any time. We did not want to have to perform a complete re-write in the event of such an occurrence. The final challenge was to display all the properties in a convenient and straight forward way. To overcome these challenges, the project was broken down into tasks: redefining the hibernate properties approach; creating data objects to model the properties; creating an engine to read and write properties; and finally creating a GUI to allow users to easily manipulate the properties. This led logically to breaking the component in to four distinct objects: HibernateProperty, HibernatePropertiesModel, ConfigurationEngine and ConfigurationPanel 
(see Figure \ref{configutilclassdiagram}). This approach also conveniently and purposely uses the MVC (Model, View, Controller) design patter to separate the presentation from the data and the control. In this design, the HibernateProperty and HibernatePropertiesModel are the data or model component; ConfigurationEngine is the controller component; and ConfigurationPanel is the view component. It should also be mentioned that two new exceptions were created: CouldNotLoadPropertiesException and NoHibernatePropertiesException. These apply when the user of the configuration tool is trying to do something that fails. They are important to inform the caller of the issue, so appropriate action can be taken.

\begin{figure}[placement]
\begin{center}
\pgfimage[height=6cm,width=12cm]{Images/configutilclassdiagram}
\caption{XmlPipeDb Utilities - Configuration Utility Class Diagram}
\label{configutilclassdiagram}
\end{center}
\end{figure}

A thorough examination of the hibernate properties showed that properties could be easily broken into categories and types. Categories are platforms, general and connection pools. Platforms contain the different database platforms supported by hibernate via direct connection, e.g. PostgreSQL, MySQL, etc. Connection pools are the different connection pools, such as C3PO or Apache DBCP, that are supported. General are properties that apply to any setup, regardless of whether it is a direct connection or a connection pool. Types are used to identify the specific type of property within the category, e.g. PostgreSQL is a type within the platforms category and C3PO is a type within the connection pools category.

The data structures to support this breakdown consist of a Hibernate Property object to store each individual property and a HibernatePropertiesModel as a container for the HibernateProperty objects. HibernateProperty objects consist of a category, type, name and value, as well as an indicator of whether the property is saved or not. This allows both saved and unsaved properties to be stored in the same model. The ConfigurationEngine loads the default data structure for properties along with default values into a HibernatePropertiesModel. The saved properties are then read in and layered on top of the default data model, replacing the default values for those properties that were saved. The resulting model contains all the possible properties, and the values for those that were saved. 

The model is used by the ConfigurationPanel to render the a GUI for the user to view and/or edit the properties. However, if a different GUI were desired, the  ConfigurationEngine, HibernatePropertiesModel and HibernateProperty objects could be reused. When properties are saved, a model object is passed back to the controller, which then stores the properties in a file.

\paragraph{Evaluation}
Overall, the component works well. It will save the properties selected with the values entered and it will produce a Hibernate Configuration object that can be used to access a database. All this is done graphically and in case hibernate changes what databases it supports, for example, the configuration tool can be changed too, simply by updating its configuration file. From a developer and end user perspective, the tool is easy to use, in that no configuration of the configuration tool is required. It will default to picking up its properties from the jar in which it runs. Or if it is run exploded, it will pick the internal configuration up from the folder. When it persists the properties that were set, it does not require any input regarding where those properties will be saved. This makes everyone's lives easier, even if at the expense of choice. Those are the strengths. 

On the other hand, it is still very much a buyer-beware type of tool. The user must know what values to input. The user must understand whether to use a connection pool or a platform and what is meant by the term platform (direct connection). The user is not given much guidance and is assumed (or required) to be something of an expert or at least experienced at database configuration. This is a draw back of the tool, from a users point of view. The GUI has an oddity, in that the combo box and the fields are displayed centered - top to bottom - rather than aligned to the top of the panel in which they are displayed. This is not very evident, unless the list of fields is very short. There is no indicator of whether something has changed, and therefore a save is required. This is a nice to have, particularly since moving from one category to another or from one type to another causes the data that was showing to be lost.

From the point of view of a developer using the tool as a component (and possibly an end user, as well) The component does not support setting of locations for hibernate mappings. This means that the Configuration object returned cannot include this information. Otherwise, from a developer point of view it is really a plug and play component. Very little coding is required to create the panel and get the Configuration object.


\paragraph{What's Next}
The emphasis in this first round of development was to develop something that was very flexible. That goal was achieved. There are a number of things that could be done to improve the product. These range from requirements to minor improvements to major work.

As a requirement of the next version, unit tests must be created to excercise the functionality of the tool. No automated unit tests were written for this component. Adding these would ensure the integrity of the methods used and that they are performing as desired. The first thing that should be done for a new version is to create a unit testing framework. 

There are some quick wins that could be attained by polishing some blemishes out of the current GUI. These would not take much work at all. The combo box and fields of the center panel should be top aligned, instead of center aligned. Enabling the revert and default functions. Revert is intended to go back to the configuration as it was when the application was started. Default loads all the properties to their default, Hibernate defined, values. Both add some flexibility for users.

The Hibernate Configuration object can hold a great variety of information. Determining what of that information is relevant to an end user and providing a mechanism for configuring that would be a dramatic enhancement. This is a larger undertaking than the previously mentioned changes. Included in this would be configuring the location of the Hibernate mapping files. However, this brings with it another set of issues. It is convenient for the caller and therefore the end user to be able to use more than one set of configuration files. Determining exactly how to incorporate this dynamism into the configuration tool would be a challenge. The utility to the developer using the configuration tool would be simply making one call to get the Configuration object and then using it straight away, without any additional handling.

Lastly, and not exclusive of the previous change, would be a complete overhaul of the GUI. The current layout works. However, that does not mean it is the best overall design for configuring these properties. In fact, some of the design might stay, but major improvements could be made in the utility of the GUI. Properties that have been set could be shown in a textarea on the top of the screen or a separate tab or even a detached window. This would provide the user with a quick overview of the properties. More guidance can be provided in setting properties correctly. Currently the default hibernate value is shown in the textfield. Once the textfield is changed, this information is lost. The hibernate default could be put into a tooltip, so that it is always available to the user. In that vein, additional information could be provided, particularly for properties that are not necessarily intuitively configured. Provide a way to test the setup would allow the user to be sure that everything was correct before continuing. This should take the form of opening a connection to the database and, in the event of a failure, reporting as closely as possible what failed in establishing the connection (e.g. bad URL, bad login, etc.). Lastly, the way properties are set could be re-examined. The options may be layed out differently or in more of a guided format to provide the user a better feeling for what they are expected to do.



