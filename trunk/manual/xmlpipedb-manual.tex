\documentclass[11pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{url}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\newcommand{\species}[1]{\emph{#1}}
\newcommand{\gdbtable}[1]{\textsl{#1}}
\newcommand{\gdbfield}[1]{\textsl{#1}}
\newcommand{\uilabel}[1]{\textsl{#1}}

\title{XMLPipeDB User and Developer's Manual}
\author{Loyola Marymount University\\
Bioinformatics Group
}
%\date{}                                           % Activate to display a given date or no date

\begin{document}
\maketitle

\pagebreak
\tableofcontents
\pagebreak

\section{Overview}

XMLPipeDB is a suite of tools for managing, querying, importing, and exporting information to/from XML data based on some specific XML schema (XSD).  While its applicability is fairly general, the original motivation for XMLPipeDB is the management of biological data from different sources.  Thus, XMLPipeDB's end-user applications are bioinformatics-oriented, although other applications may be developed using the project's underlying tools.

\subsection{Who Should Read What Part of this Document}

\begin{itemize}
\item If you are a GenMAPP user primarily interested in GenMAPP Gene Databases, Section~\ref{gdb} is for you.

\item If you would like to \emph{build} GenMAPP Gene Databases from supported XML data sources, you will want to read about GenMAPP Builder in Section~\ref{genmappbuilder}.

\item If you are a bioinformatics software developer who would like to create applications using XML data sources that have been imported into a relational database, you will want to read Section~\ref{dblib}.

\item If you are a software developer or database designer who is interested in learning how XMLPipeDB's end-user applications were developed, and would like to new Java libraries for working with XML data sources within a relational database, you will want to read Section~\ref{devtools}.

\item Finally, if you are a software developer who wishes to participate in or contribute to the XMLPipeDB project, you will want to read Appendix~\ref{dev}.
\end{itemize}

\section{Developer Tools}
\label{devtools}

Many components in XMLPipeDB's end-user applications are actually built semi-au\-to\-mat\-ic\-al\-ly.  The XMLPipeDB project includes these tools as well.  End-users don't need to know about these tools; instead, they use the \emph{output} generated by them.  This section is for database designers and software developers who are interested in creating their own database applications using XML data sources.

\subsection{XSD-to-DB}

The XSD-to-DB application takes a well-formed XML Schema (XSD) or Document Type Definition (DTD) file and converts it into a collection of Java source code and Hibernate mapping files that allows XML files based on that XSD or DTD to be read into a relational database.  It was used to help create the UniProtDB and GODB libraries which are used by GenMAPP Builder.

XSD-to-DB's conversion functions are based on the open-source Hyperjaxb2 project (\url{https://hyperjaxb2.dev.java.net}).  It requires the following information to do its work:
\begin{itemize}
\item URL for the XSD or DTD file to process; in the case of a locally-loaded XSD or DTD, a \url{file:///} URL may be used

\item Hyperjaxb2 binding file

\item Directory that will contain its output
\end{itemize}
XSD-to-DB comes with a default binding file, which it copies into its output directory when it is invoked for the first time.  Additional customization can then be performed on the copied binding file, and subsequent invocations of XSD-to-DB will use that binding instead of the default.

\subsubsection{Usage}

XSD-to-DB is currently packaged as a command-line Java application in an executable JAR, \texttt{xsd2db.jar}.  As such, it can be invoked in a number of ways:
\begin{itemize}
\item Direct JAR invocation via \texttt{java -jar xsd2db}
\item Running one of the provided shell scripts (i.e., \texttt{xsd2db} or \texttt{xsd2db.bat})
\end{itemize}
In both cases, command line options are expected, described below.
\begin{description}
\item[\texttt{--xsdURL=\emph{url}}] The URL for the XSD to convert; required when XSD-to-DB is run for the first time, or when \emph{updateXSD} (see below) is requested.

\item[\texttt{-dtdSchema}] Switch that tells XSD-to-DB to expect a DTD file in the provided \texttt{--xsdURL}.

\item[\texttt{--outputDirectory=\emph{dir}}] The directory to use when generating (or re-generating) the database source code and files; defaults to \texttt{db-gen}.  Specifying a non-existent or empty directory essentially counts as a ``first-time run'' of XSD-to-DB.

\item[\texttt{--bindings=\emph{filename}}] The bindings file to use when generating the database source code and files for the first time; this file is then copied into the \texttt{xsd} subdirectory.  Defaults to a standard bindings file supplied by XSD-to-DB.

\item[\texttt{-updateXSD}] Replaces the XSD being used with a new version; applicable only after XSD-to-DB has been run for the first time.

\item[\texttt{-help}] Displays a help message for how to use \texttt{xsd2db} (roughly a summarized version of this option list).
\end{description}

\subsubsection{What XSD-to-DB Does}

If you invoke it without any arguments, XSD-to-DB will issue a message requiring the URL of the XSD or DTD file to convert.  Once the URL has been provided, XSD-to-DB then processes it produces Java source code, Hibernate mapping files, and an SQL DDL file that corresponds to the schema defined by the XSD file.  These files are placed in an output directory, which defaults to \texttt{db-gen} if it isn't otherwise specified.

XSD-to-DB behaves a little differently depending on the presence of certain files in the output directory, or even the presence of the output directory itself.  If the output directory is not present, then XSD-to-DB does the following:
\begin{enumerate}
\item Create the output directory.
\item Copy the XSD file from its given URL to the output directory.
\item Copy the default XSD-to-DB bindings file to the output directory.
\end{enumerate}
If the output directory already exists, then XSD-to-DB looks for the XSD and bindings files at the expected locations within that directory.  If those files are not present, then it performs the same steps as before.
\begin{itemize}
\item XSD-to-DB can be told whether or not to update the XSD file from its URL, in case the XSD file might have changed.  If it is told to perform an update, it will ask for the URL of the updated XSD file.
\end{itemize}
Once the output directory has been set up, XSD-to-DB then processes the XSD and bindings files to generate:
\begin{itemize}
\item Java source code for classes represented in the XSD
\item SQL DDL file defining the relational database tables that correspond to the Java classes
\item Hibernate mapping files that determine how the Java classes are convert to and from the relational tables
\item An Apache Ant \texttt{build.xml} file which can compile everything into a Java archive, ready for further development or deployment
\end{itemize}
From this point, a typical workflow would be:
\begin{enumerate}
\item Build a relational database using the generated SQL DDL file
\item Build the database library using the supplied Ant file, then use that library to test XML import, queries, and other database functions
\item Edit the bindings file to customize, correct, or improve the Java classes, Hibernate mappings, and relational tables generated from the XSD file
\item Re-run XSD-to-DB to actually create the new files
\end{enumerate}
Certain conversions might not be adequate even with extensive editing of the bindings file; in this case, the last resort is to manually edit the Java, Hibernate, and SQL files generated by XSD-to-DB.  If this is done, be careful about re-running XSD-to-DB on this particular output directory --- XSD-to-DB \emph{always} generates the Java, Hibernate, and SQL files ``from scratch,'' using the XSD and bindings files in the output directory.

Typically, once the generated files work as desired, the output directory becomes a software project in and of itself, to be edited, debugged, tested, and deployed like any other database library.  The fact that it was initially generated by XSD-to-DB merely indicates that some time was saved in creating this database library as compared to a manual Java-to-relational implementation of the XSD file.

\subsubsection{Output Details}

XSD-to-DB's output directory structure is shown in Figure~\ref{output}.  Directories are shown in boldface, and files are shown in italics.  Names in parentheses indicate placeholders for specific names that depend on the XSD being converted.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=2in]{figures/db-gen.pdf} 
   \caption{Structure of an XSD-to-DB output directory.}
   \label{output}
\end{figure}

The actual filenames and contents of terms in angle brackets $(< >)$ depend on the XSD file that was used to generate the output.  For instance, the UniProtDB library has \texttt{uniprot.xsd}, \texttt{uniprot-bindings.xml}, and \texttt{uniprot.sql}.

\subsection{XMLPipeDB Utilities}
\label{xmlpipedbutils}

The XMLPipeDB Utilities library is a suite of Java classes that provide functions that are common to most XMLPipeDB database applications.  Specifically, the library includes reusable classes for:
\begin{itemize}
\item Loading of XML files into Java objects, and subsequent saving of these XML-derived Java objects to a relational database
\item Rudimentary query and retrieval of Java objects from the relational database
\item Configuring a client application to communicate with a relational database
\end{itemize}
XMLPipeDB Utilities includes a sample GUI application that demonstrates these functions, using database code that was generated by XSD-to-DB.

\subsubsection{Usage}

XMLPipeDB Utilities is packaged in two JAR files: \texttt{xpdutils.jar} and \texttt{xpdutils-demo.jar}.  \texttt{xpdutils-demo.jar} contains a demo BookDB application that shows how to use XMLPipeDB utilities.  \texttt{xpdutils.jar} contains the utilities themselves; to write programs using XMLPipeDB Utilities, include \texttt{xpdutils.jar} in the Java classpath of the program you are writing.

\subsubsection{What XMLPipeDB Utilities Provides}

The library is separated into two layers: one layer provides the functionality, meant to be called programmatically, and another layer is a set of user interface components that allow end-user to invoke those functions.  Figure~\ref{utils} provides an overview of the library.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=5in]{figures/xmlpipedb-utilities.pdf} 
   \caption{Overview of XMLPipeDB Utilities.}
   \label{utils}
\end{figure}

The XMLPipeDB Utilities library relies heavily on JAXB and Hibernate --- in many respects, it is a convenience and GUI layer for these packages --- so knowledge of these APIs is very helpful in making full use of XMLPipeDB Utilities.

\paragraph{Utility Functions}

The following classes implement the functions provided by XMLPipeDB Utilities:
\begin{itemize}
\item \texttt{ImportEngine} provides a \emph{loadToDB()} method, which takes any compliant input stream, parses it into its corresponding objects, then commits the objects to the database.

\item \texttt{ConfigurationEngine} is the centralized location for configuration information used by XMLPipeDB.  It provides functions for retrieving, setting, and validating configuration properties. The ConfigurationEngine also has a method for obtaining a Hibernate Configuration object, which is needed by ImportEngine and QueryEngine. The configuration object, however, only contains the Hibernate properties and NOT the mapping files. Hibernate mappings must be added by the caller before passing the Configuration object to the Query or Import Engines.

\item \texttt{QueryEngine} is a generalized query wrapper whose \emph{executeHQL()} function takes a Hibernate query (in HQL, Hibernate Query Language) and returns the results as a Java iterator.
\end{itemize}
Programs using the XMLPipeDB Utilities library can invoke these functions as necessary, using whatever mechanism is most appropriate for a particular application.

\paragraph{User Interface Components}

To ease the development and delivery of these functions to end-user applications, XMLPipeDB Utilities also includes a component library that can be added directly into Java Swing windows and panels.  Each component provides a ``hook function'' that invokes the underlying operation, assuming that sufficient information has been gathered by the component:
\begin{itemize}
\item \texttt{ImportPanel} provides a front end for database imports, displaying components like file choosers, text editors, and preview panels to make database loading as easy as possible for end-users.

\item \texttt{ConfigurationPanel} provides a front-end for the properties in \texttt{ConfigurationEngine}.  The components are designed to be easily added to dialog boxes or preferences windows, and provide direct hooks to the \texttt{Configurator} functions.

\item \texttt{HQLPanel} allows users to enter an HQL (Hibernate Query Language) or SQL (Structured Query Language) query then provides a table or object browser that displays the results of that query.  This is meant primarily for debugging or advanced purposes, as it requires knowledge of the underlying database schema and/or domain object model.  HQL queries are processed by \texttt{QueryEngine}.
\end{itemize}
The demo application that comes with XMLPipeDB Utilities shows how these components are used, and how they interact with the underlying functionality.  GenMAPP Builder also uses XMLPipeDB Utilities for its import, configuration, and query functions.

\section{Database Libraries}
\label{dblib}

XMLPipeDB has used XSD-to-DB to generate Java database libraries for UniProt and Gene Ontology (GO) data sources, called UniProtDB and GODB, respectively.  These database libraries use JAXB to convert XML files from these data sources into Java objects, then use Hibernate to persist these Java objects in a relational database, a schema for which is provided with the distribution.  To use these libraries in other software, you will need the following in your Java classpath:
\begin{itemize}
\item the database library itself (\texttt{uniprotdb.jar}, \texttt{godb.jar}, etc.)
\item Hibernate
\item JAXB
\item JDBC driver for your relational database
\end{itemize}
The libraries work like standard JAXB applications when importing XML files: the data in the loaded file gets converted into a set of corresponding objects.  The libraries then work like standard Hibernate applications when saving these objects to the database: configure Hibernate, then use its classes to save/update the objects or to perform HQL queries.

To further assist in software development, you may want to look at XMLPipeDB Utilities (Section~\ref{xmlpipedbutils}), which provide frequently-used routines and GUI components that are usually needed by applications using these libraries.

\subsection{UniProtDB}

UniProtDB is the library of Java classes that allows UniProt XML files to be transferred into a relational database.  GenMAPP Builder uses the UniProtDB library; in turn, the UniProtDB library is semi-automatically generated from the XMLPipeDB project's XSD-to-DB tool.

\subsubsection{Usage}

To use UniProtDB in an application, follow these steps.  Note that some familiarity with the JAXB and Hibernate APIs is required in order to use UniProtDB.
\begin{enumerate}
\item Include \texttt{uniprotdb.jar} in the Java classpath.

\item Initialize a relational database with the schema provided in \texttt{schema.sql}.

\item At the point where the application configures Hibernate, add \texttt{uniprotdb.jar} to the Hibernate configuration via the \texttt{addJar()} method.  Also, make sure that Hibernate is configured for the relational database that was set up in the previous step.

\item Use the JAXB API to read UniProt XML files into Java objects, then use the Hibernate API to persist these objects to the relational database.

\item The XMLPipeDB Utilities library may be helpful in implementing some frequently-used functions such as XML import, configuration, and ad-hoc HQL querying.
\end{enumerate}

\subsubsection{Implementation Notes}

XSD-to-DB's ``as is'' output from reading the UniProt XSD \cite{uniprotxsd} required some post-processing prior to becoming usable in database applications.  Specifically, the following changes needed to be made:
\begin{itemize}
\item The UniProt XSD defines an \textsl{end} element.  Unfortunately, \textsl{end} is an SQL reserved word.  Thus, the post-processor renames \textsl{end} to \textsl{endPosition}.

\item Some XSD data types, particularly the range of options for XML dates, are not easily supported in SQL.  In particular, XSD dates allow month-year values with unspecified dates, or even just years.  This does not translate well to SQL and Java.  It was concluded that values which were defined this way in the UniProt XSD can acceptably be represented as strings.  This date mismatch occurred only once, in UniProt's \textsl{citationType} definition.  \textsl{citationType}'s \textsl{date} attribute was defined as:

\begin{verbatim}
<xs:simpleType>
    <xs:union memberTypes="xs:date xs:gYearMonth xs:gYear"/>
</xs:simpleType>
\end{verbatim}

\item Another data type issue concerns strings.  The libraries used by XSD-to-DB translated strings into SQL \texttt{varchar(255)}.  However, many string values in UniProt XML files exceed 255 characters in length.  Thus, instances of \texttt{varchar(255)} are converted into just \texttt{varchar} (unspecified length).
\end{itemize}
The UniProtDB post-processor is included in the \texttt{tools} subdirectory of the \texttt{uniprotdb} module in the XMLPipeDB CVS repository.  Note that the post-processor only needs to be invoked if the UniProtDB files have been rewritten by XSD-to-DB.  As committed, the files in the repository are already post-processed.

\subsection{GODB}

Information from the GO (Gene Ontology) database is required to run GenMAPP Builder.  GODB provides a library of Java classes and Hibernate mapping (HBM) files that allows data from GO OBO XML files to be transfered into a relational database.  The library is delivered and used as a Java Archive (JAR) file called \texttt{godb.jar}. The classes and HBM files generated by \texttt{xsd2db} are processed by a utility called \texttt{GodbPostProcessor} prior to being built into the JAR file.  This is required because of some irregularities in the output provided by Hyperjaxb.

\subsubsection{Usage}

GODB includes a pre-built, ready-to-use copy of \texttt{godb.jar}.  This may be used in GenMAPP Builder or in any other application you wish to build.

To use GODB in an application, follow these steps.  Note that some familiarity with the JAXB and Hibernate APIs is required in order to use GODB.
\begin{enumerate}
\item Include \texttt{godb.jar} in the Java classpath.

\item Initialize a relational database with the schema provided in \texttt{schema.sql}.

\item At the point where the application configures Hibernate, add \texttt{godb.jar} to the Hibernate configuration via the \texttt{addJar()} method.  Also, make sure that Hibernate is configured for the relational database that was set up in the previous step.

\item Use the JAXB API to read GO OBO XML files into Java objects, then use the Hibernate API to persist these objects to the relational database.

\item The XMLPipeDB Utilities library may be helpful in implementing some frequently-used functions such as XML import, configuration, and ad-hoc HQL querying.
\end{enumerate}

\subsubsection{Implementation Notes}

XSD-to-DB's ``as is'' output from reading the GO DTD \cite{godtd} required some post-processing prior to becoming usable in database applications.  Specifically, the following changes needed to be made:
\begin{itemize}
\item The GO DTD defines an \textsl{to} element.  Unfortunately, \textsl{to} is an SQL reserved word.  Thus, the post-processor renames \textsl{to} to \textsl{to\_}.

\item Another data type issue concerns strings.  The libraries used by XSD-to-DB translated strings into SQL \texttt{varchar(255)}.  However, many string values in GO OBO XML files exceed 255 characters in length.  Thus, instances of \texttt{varchar(255)} are converted into just \texttt{varchar} (unspecified length).
\end{itemize}
The GODB post-processor is included in the \texttt{tools} subdirectory of the \texttt{godb} module in the XMLPipeDB CVS repository.  Note that the post-processor only needs to be invoked if the GODB files have been rewritten by XSD-to-DB.  As committed, the files in the repository are already post-processed.

GODB needs to be regenerated if the GO OBO XML DTD changes.  However, in this case, the utility provide to do the post processing, \texttt{GodbPostProcessor}, may also need to be updated, since new issues may be introduced with the GO schema change.

Regenerating GODB is a multi-step process:
\begin{enumerate}
\item Run \texttt{xsd2db}, providing the GO DTD URL as input
\item Run GodbPostProcessor on the \texttt{xsd2db} output.
\item Run ANT using the \texttt{build.xml} in the root of the GODB directory.
\end{enumerate}

\subsection{Database Administration and Setup}
\label{dbsetup}

The applications and libraries in XMLPipeDB require any relational database for which a JDBC driver exists.  Thus, they all require some degree of configuration, for specifying the database server, database name, username, password, etc.  To facilitate this, XMLPipeDB includes a common database configuration GUI in all of its applications.  Any other mechanism may also be used if desired, since database access is strictly ``standard'' JDBC and/or Hibernate.

Once a JDBC-ready database server has been successfully installed, the schema for the database needs to be instantiated within that server.  XMLPipeDB modules provide one or more \texttt{.sql} files for doing this; executing the commands in those files within the database server instantiates the schema.  In the case of UniProtDB and GODB, the schema file is called \texttt{schema.sql}.  For GenMAPP Builder, the file is \texttt{gmbuilder.sql}

%to be written: specific steps for PostgreSQL

\section{End-User Software}
\label{endUserSoftware}

XSD-to-DB, XMLPipeDB Utilities, UniProtDB, and GODB are primarily for software developers.  This section discusses the components of XMLPipeDB that are geared toward end-users, particularly bioinformaticians.

\subsection{Pre-Built GenMAPP Gene Database Files}
\label{gdb}

If your primary interest is to use GenMAPP for a particular organism, please consult the following list for GenMAPP files that have already been created using GenMAPP Builder (Section~\ref{genmappbuilder}).  In many cases, you can simply download them and point GenMAPP to them, and you'll be ready to load up expression data sets.  Full details on GenMAPP are available on the GenMAPP Web site (\url{http://www.genmapp.org}).

\begin{itemize}
\item \species{Escherichia coli} K12
%\item \species{Pseudomonas putida}
%\item \species{Bacillus subtilis}
\end{itemize}

\subsubsection{Overview of the GenMAPP Application and Accessory Programs}

GenMAPP (Gene Map Annotator and Pathway Profiler) is a free computer application for 
viewing and analyzing DNA microarray and other genomic and proteomic data on biological pathways.   MAPPFinder is an accessory program that works with GenMAPP and Gene Ontology to identify global biological trends in gene expression data. The GenMAPP Gene Database (file with the extension \texttt{.gdb}) is used to relate gene IDs on MAPPs (\texttt{.mapp}, representations of pathways and other functional groupings of genes) to data in Expression Datasets (\texttt{.gex}, DNA microarray or other high-throughput data).  GenMAPP is a stand-alone application that requires the Gene Database, MAPPs, and Expression Dataset files to be 
stored on the user's computer. GenMAPP and its accessory programs and files may be downloaded from \url{http://www.GenMAPP.org}.  GenMAPP requires a separate Gene Database for each species.

\subsubsection{System Requirements and Compatibility}
The Gene Databases produced by XMLPipeDB are compatible with GenMAPP 2.0 and 2.1 and MAPPFinder 2.0.  These programs can be downloaded from \url{http://www.genmapp.org}.  GenMAPP 2.0/2.1 and MAPPFinder 2.0 have the following requirements:
\begin{itemize}
\item \emph{Operating system:} Windows 98 or higher, Windows NT 4.0 or higher (2000, XP, etc.) 
\item \emph{Monitor resolution:} 800 $\times$ 600 screen or greater (SVGA)
\item \emph{Web browser:} Microsoft Internet Explorer 5.0 or later
\item \emph{Minimum hardware configuration:}
\begin{itemize}
\item \emph{Memory:} 128 MB (512 MB or more recommended) 
\item \emph{Processor:} Pentium III
\item \emph{Disk space:} 300 MB disk (more recommended if multiple databases will be used) 
\end{itemize}
\end{itemize}
 
\subsubsection{Usage}

\begin{enumerate}
\item Extract the zipped archive and place the \texttt{.gdb} file in the folder you use to 
store Gene Databases for GenMAPP. If you accept the default folder during the GenMAPP 
installation process, this folder will be \texttt{C:$\backslash$GenMAPP 2 Data$\backslash$Gene Databases}.

\item To use the Gene Database, launch GenMAPP and go to the menu item \uilabel{Data} $>$ \uilabel{Choose Gene Database}. Alternatively, you can launch MAPPFinder and go to the menu item \uilabel{File} $>$ \uilabel{Choose Gene Database}.
\end{enumerate}

\subsubsection{\species{E.\ Coli} K12 Gene Database Specifications}

\paragraph{Gene ID Systems}

The \species{Escherichia coli} K12 Gene Database is ``UniProt-centric'' in that the main data 
source (primary ID system) for gene IDs and annotations is the UniProt complete proteome set 
for \species{Escherichia coli} K12, made available as an XML download by the Integr8 resource. In addition to UniProt IDs, this database provides the following proper gene ID systems that were cross-referenced by the UniProt data: Blattner, EchoBASE, and EcoGene.  It also supplies 
UniProt-derived annotation links from the following systems: EMBL, InterPro, PDB, and Pfam.  The Gene Ontology data has been acquired directly from the Gene Ontology Project.  The GOA 
project was used to link Gene Ontology terms to UniProt IDs.  Links to data sources are listed in the section below.

\paragraph{Species}

The Gene Database is based on the UniProt proteome set for \species{Escherichia coli} K12, taxon ID 83333.  Two substrains of \species{E.\ coli} K12 have had their genome sequenced, MG1655 and W3110.  This Gene Database contains data for the MG1655 strain (Blattner IDs). UniProt has a separate proteome set for the W3110 strain (taxon ID 316407).  The W3110 strain uses IDs of the form ``JWxxxx'' and are not supported in this Gene Database. 

\paragraph{Data Sources and Versions}

The current \species{Escherichia coli} K12 Gene Database was built on July 31, 2006; this build date is reflected in the filename \texttt{Ec-Std\_20060731.gdb}.  All date fields internal to the Gene Database (and not usually seen by regular GenMAPP users) have been filled with the build date.  Versioning information for the individual data sources is given below.
\begin{itemize}
\item UniProt complete proteome set for \species{Escherichia coli} K12, made available as an XML download by the Integr8 resource:

\url{http://www.ebi.ac.uk/integr8/FtpSearch.do?orgProteomeId=18}

The XML filename is \texttt{18.E\_coli\_K12.xml}, downloaded as a compressed \texttt{.gz} file and extracted.  Version information for the proteome sets can be found at:

\url{http://www.ebi.ac.uk/integr8/HelpAction.do?action=searchById&refId=5}

The proteome set used for this version of the \species{Escherichia coli} K12 Gene Database was based on UniProt Knowledgebase release 8.3 on July 11, 2006.

\item Gene Ontology gene associations are provided by the GOA project: 

\url{http://www.ebi.ac.uk/GOA}

The gene associations are represented as a tab-delimited text file. The \species{Escherichia coli} K12 GOA file was accessed from the Integr8 proteome set download page:

\url{http://www.ebi.ac.uk/integr8/FtpSearch.do?orgProteomeId=18}

The GOA filename is \texttt{18.E\_coli\_K12.goa}, downloaded as a compressed \texttt{.gz} file and extracted.  The GOA file for this version of the \species{Escherichia coli} K12 Gene Database was based on the July 2006 release of GOA (version information can be found as a date field within the GOA file itself).

\item Gene Ontology data is downloaded from:

\url{http://www.godatabase.org/dev/database/}
 
We use the monthly release available at the first of every month.  For this version of the 
\species{Escherichia coli} K12 Gene Database, we used the July 1, 2006 release.  The file's name is \texttt{go\_200607-termdb.obo-xml.gz}.  We extract the file and reverse the period and 
hyphen in the filename so it reads \texttt{go\_200607-termdb-obo.xml}.
\end{itemize}

\paragraph{Database Report}

\begin{itemize}
\item UniProt is the primary ID system for the \species{Escherichia coli} K12 Gene Database. The UniProt table contains all 4329 UniProt IDs reported in the UniProt proteome set for this species.

\item The Blattner IDs were derived from the cross-references in the UniProt XML for \species{Escherichia coli} K12.  We compared our Blattner table with the table in the supplementary material from \cite{riley-e-coli}, \texttt{Supplementary\_Table\_1\_Annotation\_E.\_coli\_Genes.xls}.  Our Blattner table contains 4466 identifiers. There are 219 Blattner IDs reported in the Riley et.\ al.\ table that are not in our Gene Database.  Of these:
\begin{itemize}
\item 157 are RNA genes (tRNA, rRNA, or misc\_RNA) 
\item 1 is the origin of replication 
\item 51 are protein coding sequences (CDS) 
\item 10 do not have a feature designation 
\end{itemize}
Conversely, there are 200 Blattner IDs in our table that are not in the Riley table:
\begin{itemize}
\item 104 are in the form of ``ECOK12Fxxx'' and correspond to proteins encoded by plasmid F
\item 51 contain a period in the ID, such as ``bxxxx.y''
\item 45 are IDs that have been supplanted by a new ID, but are reported in UniProt as 
synonyms to other Blattner IDs
\end{itemize}

\item The \species{Escherichia coli} K12 Gene Database also contains 4156 EchoBASE IDs and 4224 EcoGene IDs that were cross-referenced by the UniProt XML.
\end{itemize}

\subsection{GenMAPP Builder}
\label{genmappbuilder}

GenMAPP Builder is an application for creating GenMAPP Gene Database files, or GDBs.  These files are actually Microsoft Access database files (MDBs) with a \texttt{.gdb} filename extension.\footnote{GenMAPP handles three types of MDB files, distinguished by an extension other than \texttt{.mdb}: Gene Databases (\texttt{.gdb}), MAPPs (\texttt{.mapp}), and Expression Datasets (\texttt{.gex}).}

The application works by first importing supported data files into a relational database.  The database can then be queried %by organism <--- bug fix needed first!
in order to produce a GenMAPP database file.  %(restore when fix is done) While one UniProt import per species would be the norm, there is no actual restriction on the content of the imported XML.  With a sufficiently large and fast workstation, one can theoretically import the entire UniProt dataset into GenMAPP Builder's internal database.
At this writing, only one species may be imported into the relational database.  Future versions of GenMAPP Builder will be able to store and export multiple species.

%[I think this needs to be reworded; unless we decide later to work with the entire UniProt (or some other database) the files imported into the relational database will already be organism-specific data files.]  [yes, this general direction was the intent; in that case, would additional clarification still be necessary?  or, for simplicity, should we start by assuming that we have a single-organism assumption for now?] [We could say just that:  Currently, the program expects species-specific files; in the future, files that contain data from multiple species could be used and queried by species.]

\subsubsection{Supported Data Sets}
\label{supportedDataSets}

The current version of GenMAPP Builder requires data from the following types of files in order to build a GenMAPP Gene Database file:
\begin{itemize}
\item UniProt XML
\item Gene Ontology (GO) OBO XML
\item Tab-delimited GO gene associations (various sources, primarily GOA)
\end{itemize}
Typically, the GO file need only be loaded once, since GO makes the entire set of terms available as a single download.  UniProt XML files can be downloaded by species from the Integr8 Web interface.  %While one UniProt import per species would be the norm, there is no actual restriction on the content of the imported XML.  With a sufficiently large and fast workstation, one can theoretically import the entire UniProt dataset into GenMAPP Builder's internal database.

Once the source files have been imported into the relational database, they are no longer needed; exports can be performed any number of times after that.  In practice, however, periodic reloads will be necessary in order to remain in sync with the datasets' providers.

\subsubsection{Requirements}

To use GenMAPP Builder, you need:
\begin{itemize}
\item A Java 5 runtime environment
\item A relational database with an available JDBC 3 driver; however, at this writing, only PostgreSQL has been used and tested
\item One or more data sets downloaded from the Internet, from data sources that are currently supported by GenMAPP Builder
\end{itemize}
Once these are properly installed and operational, you can perform these primary functions:
\begin{enumerate}
\item Import one or more supported data files into the GenMAPP Builder database
\item Perform pre-processing on the imported Gene Ontology terms
\item Build a GenMAPP Gene Database file based on a particular species in the database
\end{enumerate}
The built files can then be read directly by GenMAPP.

\subsubsection{Database Setup}

Using GenMAPP Builder requires one setup step that is external to the GenMAPP Builder application: setting up the intermediate relational database that GenMAPP Builder uses to store imported XML information. This database is technically any relational database for which a JDBC 3 driver is available, although thus far only PostgreSQL has been used and tested.

To set up the GenMAPP Builder intermediate database, perform the following steps:
\begin{enumerate}
\item Install the database server --- this varies according to the specific database server software that you have chosen.  For PostgreSQL, this involves installing the software, initializing a database cluster using the \texttt{initdb} program, then starting the server using the \texttt{pg\_ctl} script or invoking \texttt{postmaster} directly.

\item Load the GenMAPP Builder schema file (\texttt{gmbuilder.sql}) into the relational database.  Specifics for this step also vary depending on the database server that is used.  For PostgreSQL, this step requires the creation of a named database using the \texttt{createdb} command, then importing the \texttt{gmbuilder.sql} file into that database through \texttt{psql}.
\end{enumerate}
Once the database has been set up, all other configuration activities can be performed from the GenMAPP Builder application.

\subsubsection{Configuration}

When GenMAPP Builder is run for the first time, a configuration dialog appears (Figure~\ref{config}).  A valid configuration is required in order for GenMAPP Builder to operate properly; many problems are caused by incorrect database settings.  The configuration can be changed at any time via the \uilabel{Configure Database} command in the \uilabel{File} menu.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=5in]{figures/config.png} 
   \caption{GenMAPP Builder configuration dialog.}
   \label{config}
\end{figure}

The configuration dialog provides an interface for a wide variety of database-related settings; many of these can be left at their default values.  The most important item to configure is the database server itself, a sample of which is shown in Figure~\ref{config}:
\begin{enumerate}
\item Select the \uilabel{Platforms} radio button.
\item Select the relational database that you are using from the drop-down menu.
\item Fill out the relevant settings from the list that appears.
\end{enumerate}
The example shown in Figure~\ref{config} shows a GenMAPP Builder installation that uses a PostgreSQL relational database called \emph{gmbuilder} on a server that is running on the same machine as GenMAPP Builder (\emph{localhost}\/) using the default PostgreSQL network port, 5432.  The standard PostgreSQL database driver is used (\emph{org.postgresql.Driver}\/), and the database username is \emph{jsmith} with an accompanying password.

Most of the time, these are the only settings to modify.  Click the \uilabel{Save} button when configuration is complete, then click \uilabel{Close} to dismiss the configuration dialog.

GenMAPP Builder relies on the Hibernate library for its database interactions; a full reference of all settable parameters can be found on the Hibernate Web site (\url{http://www.hibernate.org}).

%fine for now; I’m going to need a primer on this so that I can understand it sufficiently for demo at ISMB--KD

\subsubsection{File Import}

A ``fresh'' install of GenMAPP Builder contains no data --- supported files must be \emph{imported} into the relational database first.  There is one \uilabel{Import} command for each supported dataset, and these commands are all available under the application's \uilabel{File} menu (Figure~\ref{fileMenu}).

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=1in]{figures/fileMenu.png} 
   \caption{GenMAPP Builder \uilabel{File} menu.}
   \label{fileMenu}
\end{figure}

%[we’ll need an option here for the GO gene associations file] [yes, agreed; right now, the gene associations are read in at export time.  However, I don’t see why they can’t be loaded into the database beforehand, just as with all other files.—OK-KD]

Each import command works in the same way: once chosen, a file chooser dialog appears.  Locate the file to be imported through this dialog, then click on \uilabel{Import}.  The import process then begins.  % TODO A progress display tracks the status of the import, from which two commands are available: \uilabel{Pause} or \uilabel{Cancel}.
A dialog will notify you when the import completes; click the \uilabel{Close} button to dismiss the import dialog.

% TODO The \uilabel{Pause} command allows you to stop the import operation temporarily, to be resumed at a later time.  This may be useful for large data sets on a computer that can't be ``left alone'' to complete the entire import operation.  GenMAPP Builder tracks the list of paused imports for you; the primary requirement is that you do \emph{not} delete the files being imported until the operation is complete.

%[nice feature!][yes, when it’s actually implemented ?  But I decided to specify it here now so that we don’t forget—if this is the manuel that we are intending on packaging with the program as a stand-in for help, we will need to note that it hasn’t been implemented yet. ;) KD]

% TODO The \uilabel{Cancel} command cancels the \emph{entire} import, including data that has already been read.  This command is useful if you change your mind during an import operation, and decide not to load any of that information into the relational database after all.%[this takes us back to the “fresh” install?]
%The database remains in precisely the state that it was prior to the import command, as if the import was never invoked at all.

%[hope that sentence clarifies your question—maybe—I guess I’m just concerned that half-finished files aren’t hanging around to cause problems when trying to import a second time—KD]

Once an import operation finishes, the data in the imported file now becomes accessible as a set of relational database tables.

\subsubsection{GO Pre-Processing}

In the case of a GO OBO XML import, upon import completion GenMAPP Builder will ask if you would like to perform pre-processing of the imported GO data.  This pre-processing step is required in order for Gene Ontology-related tables to be exported correctly into the Gene Database.  Click \uilabel{OK} to proceed with pre-processing, which may take around 30 minutes.  A dialog will notify you when the GO pre-processing step completes.

The GO pre-processing step can also be performed at any time after a GO import takes place.  Choose \uilabel{File} $>$ \uilabel{Process GO Data\ldots} to do this.

\subsubsection{Browsing the Database}

GenMAPP Builder uses the query engine from XMLPipeDB Utilities to allows you to browse the contents of the underlying relational database.  With this engine, you can look at the species that are available and all imported information about the species' genes and proteins.  % TODO If a compatible GO gene associations file has also been imported into the database, you can browse the GO terms that have been associated with that species as well.

%[what did you have in mind here? what comes to my mind is that we could run queries and export stuff for purposes other than GenMAPP.  For example, you could take a list of gene IDs and find all related IDs. see the Source database run by Stanford as an example:  http://source.stanford.edu/cgi-bin/source/sourceSearch]

The query engine allows direct SQL or HQL queries, returning the results of these queries in a table or tree view (for SQL and HQL queries, respectively).  The direct queries allow for maximum flexibility in examining the loaded data, but they require detailed knowledge of the intermediate relational database schema.  % TODO For convenience, a number of particularly useful queries have been pre-loaded into GenMAPP Builder.
%(Kam — you can list as many queries here as you like; it can be an on-going task for someone to implement these queries and add them to the application as described)

% TODO Preloaded queries are available in the \uilabel{Query} menu.  When a preloaded query is invoked, a dialog may appear requesting required parameters such as taxon ID, protein name, etc.  Fill these parameters out and click on the \uilabel{Perform Query} button to view the results.

% TODO A third query mechanism is available in the form of a Google-style ``free text'' query.  For this type of query, enter the text that you would like to find, and GenMAPP Builder will return all records that somehow match this text.  The query is a simple substring search on the following fields: (this list is to be specified).

%[Whoa—I think this has bitten off more than I can chew; I’m not sure what you mean by all of this.  This would probably be best resolved by a conversation so you can explain to me what you mean by this.—KD]

\subsubsection{Building a GenMAPP Gene Database}

Once the underlying relational database contains all of the information that you need (i.e., you have imported all of the XML data sets that you wish to export to a GenMAPP Gene Database), you can build a GenMAPP Gene Database file.  To do this, choose the \uilabel{Export to GenMAPP\ldots} command from the \uilabel{File} menu.

\paragraph{Definitions}

The following definitions are helpful in assimilating the information in this section:
\begin{itemize}
\item The term ``system'' by itself is a generic term referring to any gene ID system in the abstract (e.g., UniProt).

\item A ``systems table'' generically refers to a table containing data from a particular gene ID system (e.g., the \gdbtable{UniProt} table in the GenMAPP Gene Database file is a systems table).

\item \gdbtable{Systems} (capitalized, italicized) is the specific table used by GenMAPP to determine which gene ID systems (and thus, systems tables) are present in the Gene Database.

\item A ``relations table'' generically refers to a table that relates two gene ID systems (e.g., \gdbtable{UniProt-EMBL} is a relations table that links UniProt IDs with EMBL IDs).

\item \gdbtable{Relations} (capitalized, italicized), is the specific table used by GenMAPP to determine which gene ID systems are related in the database (and thus, which relations tables should exist).
\end{itemize}

\paragraph{Export Dialog}

The export operation opens with a dialog that requests the following information.  Where possible, the destinations of these parameters in the final Gene Database are indicated.
\begin{itemize}
\item The owner of the database (limited to 200 characters): This goes in the \gdbfield{Owner} field of the \gdbtable{Info} table.

\item The creation date of the database: This defaults to the current date, and goes in the \gdbfield{Version} and \gdbfield{Modify} fields of the \gdbtable{Info} table.

\item The species to export:
%[this is going to be pre-determined by the species-specific UniProt file that is pre-loaded, unless we move towards handling the entire UniProt database, which I don’t recommend because it will be HUGE.  Therefore, it seems that this step should be at the level of UniProt, GO Gene Associations import, not at the level of GenMAPP Export.  However, we do need to fill in the Species field of the Info table and the Species fields of all the systems tables.  Maybe the dialog can pop up the question “Is this the correct species for this database?” and have it pre-filled with the species from the UniProt import process.  We will need a way to correctly give the genus-species name since GenMAPP doesn’t use taxon IDs yet.  One thing we could do is maintain a table of taxonIDs-genus/species names that we get from NCBI.  This would just be for our purposes and not make it into the final Gene Database.  I’ve just looked into what we can download from NCBI and this may not be a trivial exercise after all.][yes, while in practice, we would probably never import the entire UniProt data set, I think stating the species at this point (even if the user has only loaded one organism) accommodates the spectrum of scenarios ranging from one, to a few, to all organisms.  The import routine actually does load in the taxon ID, so we can use that for record retrieval.][As of tonight, 6/13, Joey says he can make this a drop-down menu based on the species present in the UniProt database.]
GenMAPP Builder examines the intermediate relational database and provides a drop-down menu for the species that are available there.  Select the species for which you would like to export a Gene Database.  GenMAPP Builder will automatically use this information wherever this is needed in the Gene Database, such as the \gdbtable{Info} table and the \gdbfield{Species} fields of the systems tables.

% TODO \item The systems tables to include: GenMAPP Builder presents a checklist of what systems tables are available.
%[I would like this to be set up so that the user chooses from a list of systems available.  For UniProt-centric Gene Databases, the user must at least choose UniProt as one of the systems.  The other systems that can be included in a UniProt-centric Gene Database for any species are:  EMBL, InterPro, Pfam, PDB, and OrderedLocusNames.  Then there will be additional systems available depending on the species.  For example, for E. coli we add EchoBASE and EcoGene.  We can attempt to generate this list based on the xrefs available in the XML file, but I’m afraid that not all of the xrefs that are there will be suitable for systems tables.  We will have to investigate to see if there’s some way to automatically and intelligently generate this list.  Gene Ontology will only need to be included as a system if the appropriate gene association table is available.  For each system chosen, the current date is added to the Date field of that record in the Systems table.][***NEW: Joey is going to make a list for the user to choose from, although I’m not sure how he’s generating this list, dynamically from the db xrefs or just based on the list we’ve given him—KD]

\item One of these systems tables then needs to be designated as the \emph{Model Organism Database} (MOD) system for the Gene Database.  For a UniProt-centric Gene Database, this would be UniProt.  The table name goes in the \gdbfield{MODSystem} field of the \gdbtable{Info} table.

\item Systems table display order: An explicit ordering can be specified for the systems tables, determining the order in which the systems will display in the GenMAPP Gene Finder and Backpage.  This information is stored in the \gdbfield{DisplayOrder} field of the \gdbtable{Info} table.

\item ``Primary'' systems tables: systems tables whose database references are used to build the relations tables (see next item) are considered to be \emph{primary}\/.  Relations tables that include such systems are said to have \emph{direct} relations, while relations tables whose linkages are transitively built from primary database references are said to be \emph{inferred} (e.g., if UniProt is marked as a primary systems table, and it contains references to PDB and EMBL, then UniProt-PDB and UniProt-EMBL relations tables are direct, while a PDB-EMBL relations table is inferred, because the UniProt references are used to determine related IDs between PDB and EMBL).

\item The relations tables to include: GenMAPP Builder automatically generates a default list according to an internal algorithm (specified in Section~\ref{databaseDetails}); the final list can then be modified (added to or deleted from) if desired.
%[or should this even be allowed?—Sure, as Joey showed me tonight, he’s going to show the user a list of possible relations tables and then ones the user doesn’t want can be de-selected and others can be specified if they were missed by the algorithm.  We’ll have to see how this is implemented.  Having this be editable seems like a good idea to me--KD].[This list can be populated based on the systems tables chosen above.  Note that InterPro and Pfam are used to relate to other systems, but not to each other.  The Other table does not relate to anything else. The Relations table needs to be populated with one record per relations table.—note: I wrote this before Dondi’s e-mail about an algorithm on how to determine the relations tables.]

\item The location and name of the destination Gene Database file: As required by GenMAPP, the file has a \texttt{.gdb} extension.  In addition, while not strictly enforced, the filename itself should follow this naming convention: two-letter code for genus/species, dash, the letters ``Std'' meaning standard or official, underscore, date in \texttt{yyyymmdd} format, file extension \texttt{.gdb}.  For example, an \species{E.\ coli} Gene Database generated on June 6, 2006 should, by convention, have the filename \texttt{Ec-Std\_20060606.gdb}.
\end{itemize}
When these export parameters have been set, the export operation begins.  % TODO As with the import operation, a progress display tracks the status of the export.  \uilabel{Pause} and \uilabel{Cancel} commands, which operate in the same way as their import operation counterparts, are also available while the export operation is taking place.
%[same thing about noting whether this is actually implemented yet—KD]
Once the export operation finishes, the specified destination file can be opened and used by GenMAPP.

\subsubsection{Implementation Notes}

The configuration, import, and query functions in GenMAPP Builder make direct use of the XMLPipeDB Utilities library.

\subsubsection{Database Details}
\label{databaseDetails}

GenMAPP Builder performs the following specific details in generating a Gene Database file that can be used by GenMAPP.  Based on the chosen species, GenMAPP Builder first extracts the needed information from its intermediate relational database.  Once this information has been retrieved, it is written to the specified Gene Database file as detailed in the rest of this section.

A sample GenMAPP Gene Database schema that results from the export operation appears in Figure~\ref{gdb-sample}.  The schema in the figure is the result of a GenMAPP Builder export for \species{E.\ coli} with UniProt as the model organism system table.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=7in,angle=90]{figures/e-coli-genmapp-schema.pdf} 
   \caption{Sample GenMAPP Gene Database for \species{E.\ coli}.}
   \label{gdb-sample}
\end{figure}

\begin{enumerate}
\item The export begins by copying a blank GenMAPP Gene Database file, \texttt{GeneDBTmpl.gtp}, to the specified destination file (i.e., the one specified in the export dialog).  The file is provided by GenMAPP.org, and consists of the following four tables: \gdbtable{Info}, \gdbtable{Systems}, \gdbtable{Relations}, and \gdbtable{Other}.  The template file is actually a Microsoft Access database file with the extension \texttt{.gtp}.  GenMAPP Builder comes with a default template file, but a different template file may be used since it may be changed periodically by GenMAPP.org.
%They are pretty good about keeping fields in there for historical reasons, the only changes might be additions.

\item The \gdbfield{Owner} field of the \gdbtable{Info} table is filled with the \gdbfield{Owner} text given in the export dialog.

\item The \gdbfield{Version} and \gdbfield{Modify} fields of the \gdbtable{Info} table are filled with the date given in the export dialog.

\item The \gdbfield{Species} field of the \gdbtable{Info} table is set to the genus-species designation given in the export dialog.

\item The systems tables specified in the export dialog are created.  For UniProt-centric Gene Databases, at a minimum the \gdbtable{UniProt} table is created according to the schema shown in Figure~\ref{gdb-sample}.  Other systems tables take on the schema of the \gdbtable{EMBL}, \gdbtable{PDB}, \gdbtable{InterPro}, etc.\ tables in the figure.  Each of these tables has a corresponding row in the \gdbtable{Systems} table.

\item For each systems table that gets made, the \gdbfield{Date} field of the corresponding record in the \gdbtable{Systems} table is set to the current date.

\item The \gdbtable{OrderedLocusNames} table is created from the \emph{ordered locus} name entries in the UniProt XML.  Note, for \species{E.\ coli}, this table is renamed ``Blattner'' --- an \species{E.\ coli}-specific post-processing step.

\item In the export dialog, the user was asked to designate one system as the MOD for the database.  For UniProt-centric databases, it should be UniProt.  The \gdbfield{MODSystem} field of the \gdbtable{Info} table is set to the name of this MOD system.

\item The \gdbfield{DisplayOrder} field of the \gdbtable{Info} table is set to the systems table order specified in the export dialog.  The table sequence is specified by the abbreviated code (i.e., \gdbfield{SystemCode}) of each systems table delimited by the pipe character (e.g., ``$|$S$|$Em$|$'').

\item The relations tables called for in the export dialog are created.  The default list of relations tables in that dialog is generated using the following algorithm: first, each system table is designated as being \emph{Proper} or \emph{Improper}\/, according to the \gdbfield{Misc} field in the \gdbtable{Systems} table of GenMAPP.org's existing Gene Database template file (the \gdbfield{Misc} field contains the string ``$|$I$|$'' if a systems table is improper).  ``Proper'' systems tables contain IDs that refer to individual genes or proteins as objects in the database and therefore can be used as IDs for genes/proteins on MAPPs and in Expression Datasets.  ``Improper'' systems store annotations that can refer to one or many different genes or proteins.  Pairwise relations tables between Proper systems, i.e., all possible Proper--Proper, are created, with repetitions removed (e.g., if \gdbtable{UniProt-EMBL} has been added to the relations tables list, then \gdbtable{EMBL-UniProt} will not be added).  Pairwise relations between Proper and Improper, i.e., all possible Proper--Improper, are also added to the relations tables list.  No Improper--Improper relations tables are added.

For example, the \species{E.\ coli} systems tables are classified as follows: UniProt, EMBL, EchoBASE, EcoGene, Blattner, and PDB are proper, while InterPro, Pfam, and GeneOntology are improper.

\item System tables may be marked as ``primary'' in the export dialog.  The set of primary system tables determines whether a relationship is \emph{Direct} or \emph{Inferred}\/.  If a relations table includes a system table that has been marked as primary, then it is a Direct relations table.  If neither system in the relation is marked primary, then the relations table is Inferred.  The \gdbfield{Type} field of the \gdbtable{Relations} table holds this information for each relationship table.
%[where are we storing this information?  The current GenMAPP Gene Database doesn’t store this anywhere.  Joey didn’t mention this when he told me about his implementation tonight 6/13—KD]

For example, with \species{E.\ coli}, UniProt is the sole primary systems table.  Thus, direct relations can be made between UniProt and InterPro, Pfam, PDB, EMBL, EcoGene, EchoBASE, and Blattner. All combinations between EMBL, EcoGene, EchoBASE, and Blattner and between these systems and InterPro, Pfam, and PDB are thus inferred relations.  We do not need to build indirect relations amongst InterPro and Pfam themselves, since these tables are classified by GenMAPP.org as Improper.

\item The template-provided \gdbtable{Relations} table is then filled with one record for each relations table in the exported Gene Database.

\item Gene Ontology-related tables are then created, based on the system table that has been designated as the MOD for the exported database.  These tables are \gdbtable{GeneOntologyCount}, \gdbtable{GeneOntologyTree}, and \gdbtable{MODSystem-GOCount} (e.g., \gdbtable{UniProt-GOCount}, in the case where \gdbtable{UniProt} has been designated as the MOD system table).

\item The \gdbtable{OriginalRowCounts} table is created and populated; this table can be used to verify that the tables are complete.  The information in this table should correspond to the number of records for the chosen organism that were originally imported from XML into the intermediate relational database.
%AT this point, I think Joey has made a script to count the number of records in the original UniProt XML file.  We should at least be able to compare this number to the number of records in the UniProt table in the Gene Database.

\item \emph{Species-specific post-processing.}  The variety of data sources available for a particular organism occasionally necessitates export operations that are specific to that organism.  These activities comprise the final step of the export process.

For example, in the case of \species{E.\ coli}, the following steps need to be taken:
\begin{itemize}
\item In a generic UniProt-centric Gene Database, an \gdbtable{OrderedLocusNames} table would be created.  However, in \species{E.\ coli} this table is called ``Blattner.''  Thus, for \species{E.\ coli} only, the \emph{OrderedLocusNames} system name must be changed to \emph{Blattner} in the \gdbtable{Systems} table.

\item Further, a historical artifact with Blattner identifiers results in the inclusion of multiple IDs in a single field in some cases (e.g., ``b1964/b1965/b1966'').  These IDs have to be separated into distinct records in the final Blattner table.

\item An \species{E.\ coli} Gene Database has UniProt as the MOD system table.  There are more annotation fields than are in the Ensembl-centric Gene Databases provided by GenMAPP.org; as a result, the \gdbfield{Columns} field of the \gdbtable{Systems} table's \emph{UniProt} record should be set to:
\begin{verbatim}
ID|EntryName\sBF|GeneName\sBF|ProteinName\BF|Function\BF|
\end{verbatim}
\end{itemize}
\end{enumerate}

%\section{Support}
%\label{support}
%Support can be obtained by going to xmlpipedb.sourceforge.net ??? \ldots and submitting a support request. As always, we appreciate your diligence in reading all the documentation, readme's and FAQ's before submitting a request for help. If the Uniprot XSD or GO DTD has changed and a change to the respective post processor is needed (or you suspect this to be the case), please include the version number of godb or uniprotdb that you have (this can be found in the readme file, which you would have known if you'd read it, so please go back and do this now). Since the project is staffed on an all volunteer basis, no guarantees are made about turn around on updates. However, since it is open source and the code is really, fairly straight forward, you could probably make the changes yourself and simply run the ANT build.xml provided to re-generate the jar file. Of course, if you need an update urgently and can't make the changes yourself, a small gratuity might get our butts in gear (nudge, nudge). -- your friendly neighborhood xpd team.

\appendix

\section{Developer Documentation}
\label{dev}

\subsection{Use Case Model}

Figure~\ref{usecase} shows the use case model for the various components of the XMLPipeDB project.  These use cases are the basis for the activities described in this manual.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=5.5in]{figures/use-cases.pdf} 
   \caption{Use case model for the XMLPipeDB project.}
   \label{usecase}
\end{figure}

\subsection{Guide to the Repository}

The XMLPipeDB project consists of a number of modules, listed hierarchically in Figure~\ref{cvs}.  They are related but intended to be standalone.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=2.5in]{figures/cvs.pdf} 
   \caption{Structure of the XMLPipeDB CVS repository.}
   \label{cvs}
\end{figure}

The \texttt{xsd2db} module contains the source code and libraries to XSD-to-DB.  XMLPipeDB Utilities resides in the \texttt{xmlpipedb-utils} module, including the source for its demo application.  When it is built, XMLPipeDB Utilities separates its reusable component (\emph{xmlpipedb-utils.jar}) from the demo application that uses it (\emph{xmlpipedb-utils-demo.jar}).

The sources for the UniProtDB library, which was generated by XSD-to-DB then manually customized, resides in the \texttt{uniprotdb} module.  Finally, the source code to the GenMAPP Builder application resides in the \texttt{gmbuilder} module.  Each module contains an Apache Ant \texttt{build.xml} file that can compile the source into distributable binaries; these build products are placed in the \texttt{dist} subdirectory, and should not be committed to the repository.

Similarly, output produced by XSD-to-DB (which defaults to \texttt{db-gen} in the current working directory at the time XSD-to-DB is invoked) should be committed as new modules in the repository, such as with \texttt{uniprotdb}.  Of course, the default \texttt{db-gen} name should be changed to something more descriptive.

\subsection{Building from Source}

As mentioned, building fresh binaries of each XMLPipeDB module is a matter of downloading or checking out the source then invoking Apache Ant in each module's top-level directory.  Build products are placed in the \texttt{dist} subdirectory, and should not be committed to the repository.

%\subsection{Unit Tests}

%We need them\ldots'nuff said!

\subsection{Third-Party Libraries}

XMLPipeDB ``stands on the shoulders'' of a wide variety of third-party libraries.  These libraries are always stored in the \texttt{lib/} subdirectories of each XMLPipeDB module.  Most of these third-party libraries are themselves active open source projects that continue to be developed; thus, to avoid confusion and accidental incompatibilities, all third-party libraries committed to XMLPipeDB are appended with a version number.  For example, if an XMLPipeDB module uses Jakarta Commons Logging 1.0.4, then \texttt{-1.0.4} is appended to the standard library name, so that it is stored in \texttt{lib/} as \texttt{commons-logging-1.0.4.jar}.

If a third-party library is to be updated with a new version --- and of course this new version has been verified to work with the existing code --- then its prior version should be deleted and a new file added with the appropriate version suffix.

\bibliographystyle{alpha}
\bibliography{xmlpipedb-manual}

\end{document}
